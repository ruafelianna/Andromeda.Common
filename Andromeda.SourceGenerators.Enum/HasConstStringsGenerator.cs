using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;

namespace Andromeda.SourceGenerators.Enum
{
    [Generator(LanguageNames.CSharp)]
    public class HasConstStringsGenerator : IIncrementalGenerator
    {
        public void Initialize(
            IncrementalGeneratorInitializationContext context
        )
        {
            var cls = context.SyntaxProvider
                .CreateSyntaxProvider<EnumInfo?>(
                    (node, token) =>
                    {
                        if (node is not AttributeSyntax attr)
                        {
                            return false;
                        }

                        return attr.Name switch
                        {
                            SimpleNameSyntax sns => sns.Identifier.Text,
                            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
                            _ => null,
                        } is _attrName or _attrNameShort;
                    },

                    (ctx, token) =>
                    {
                        var attrSyntax = (AttributeSyntax)ctx.Node!;

                        var parent = attrSyntax.Parent?.Parent;

                        if (parent is not EnumDeclarationSyntax enumSyntax)
                        {
                            return null;
                        }

                        var enumSymbol = ctx.SemanticModel
                            .GetDeclaredSymbol(enumSyntax, token);

                        if (enumSymbol is not ITypeSymbol enumType)
                        {
                            return null;
                        }

                        var attr = enumType
                            .GetAttributes()
                            .SingleOrDefault(x =>
                                x.AttributeClass?.ToDisplayString(
                                    SymbolDisplayFormat.FullyQualifiedFormat
                                ) == $"global::{_attrNamespace}.{_attrName}"
                            );

                        if (attr is null)
                        {
                            return null;
                        }

                        var namedArgs = attr.NamedArguments
                            .ToImmutableDictionary();

                        var clsName = (string?)namedArgs[_constClass].Value;

                        var clsNamespace = (string?)namedArgs[_constNamespace].Value;

                        if (clsName is null || clsNamespace is null)
                        {
                            return null;
                        }

                        return new(
                            enumSymbol.Name,
                            enumSymbol.ContainingNamespace
                                .ToDisplayString(
                                    SymbolDisplayFormat.FullyQualifiedFormat
                                )
                                .Substring("global::".Length),
                            clsName,
                            clsNamespace,
                            enumType
                                .GetMembers()
                                .Where(x => !x.IsImplicitlyDeclared)
                                .Select(x => x.Name)
                                .ToImmutableArray()
                        );
                    }
                )
                .Where(record => record is not null)
                .Collect();

            context.RegisterSourceOutput(cls, (ctx, source) =>
            {
                foreach (var enumInfo in source)
                {
                    var items = enumInfo!.EnumItems
                        .Select(x => $"{_tab}[{enumInfo.EnumName}.{x}] = {enumInfo.ClassName}.{x}");

                    ctx.AddSource(
                        $"{enumInfo.EnumNamespace}.{enumInfo.EnumName}.g.cs",
                        $@"// ----------------
// <autogenerated/>
// ----------------

using global::System.Collections.Generic;
using global::{enumInfo.ClassNamespace};

namespace {enumInfo.EnumNamespace}
{{
    public static class {enumInfo.EnumName}Extensions
    {{
        public static string AsString(
            this {enumInfo.EnumName} value
        ) => _{enumInfo.EnumName}Dict[value];

        private static readonly Dictionary<{enumInfo.EnumName}, string> _{enumInfo.EnumName}Dict
            = new()
            {{
{string.Join($",{_nl}", items)},
            }};
    }}
}}
"
                    );
                }
            });
        }

        private const string _tab = "                ";

        private const string _nl = "\r\n";

        private const string _attrName
            = nameof(HasConstStringsAttribute);

        private const string _attrNameShort
            = "HasConstStrings";

        private const string _attrNamespace
            = $"{nameof(Andromeda)}.{nameof(SourceGenerators)}.{nameof(Enum)}";

        private const string _constClass
            = nameof(HasConstStringsAttribute.ConstClass);

        private const string _constNamespace
            = nameof(HasConstStringsAttribute.ConstNamespace);
    }
}
