using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using static Andromeda.CSharp.Consts.Comments;
using static Andromeda.CSharp.Consts.Directives;
using static Andromeda.CSharp.Consts.Extensions;
using static Andromeda.CSharp.Consts.Keywords;
using static Andromeda.CSharp.Consts.Namespaces;
using static Andromeda.CSharp.Consts.Prefixes;
using static Andromeda.SourceGenerators.Enum.InternalConsts;

namespace Andromeda.SourceGenerators.Enum
{
    [Generator(LanguageNames.CSharp)]
    public class HasConstStringsGenerator : IIncrementalGenerator
    {
        public void Initialize(
            IncrementalGeneratorInitializationContext context
        )
        {
            context.RegisterPostInitializationOutput(GenerateAttribute);

            var source = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    $"{NS_Local}.{A_HasConstStringsFull}",
                    IsEnum,
                    TransformEnum
                )
                .Where(record => record is not null);

            context.RegisterSourceOutput(source, GenerateSourceCode);
        }

        private const string AttributeSourceCode = $@"{C_Autogenerated}

{DIR_NullableRestore}

{KW_Using} {PRE_Global}{NS_System};

{KW_Namespace} {NS_Local}
{{
    [{nameof(AttributeUsageAttribute)}({nameof(AttributeTargets)}.{nameof(AttributeTargets.Enum)})]
    {KW_Internal} {KW_Class} {A_HasConstStringsFull} : {nameof(Attribute)}
    {{
        {KW_Public} {KW_String}? {P_HasConstStrings_ConstNamespace} {{ {KW_Get}; {KW_Set}; }}

        {KW_Public} {KW_String}? {P_HasConstStrings_ConstClass} {{ {KW_Get}; {KW_Set}; }}

        {KW_Public} {KW_String}? {P_HasConstStrings_ExtNamespace} {{ {KW_Get}; {KW_Set}; }}

        {KW_Public} {KW_String}? {P_HasConstStrings_ExtClass} {{ {KW_Get}; {KW_Set}; }}
    }}
}}";

        private record EnumInfo(
            string EnumName,
            string EnumNamespace,
            ImmutableArray<string> EnumItems,
            string ClassName,
            string ClassNamespace,
            string ExtName,
            string ExtNamespace
        );

        private static bool IsEnum(
            SyntaxNode node,
            CancellationToken token
        ) => node is EnumDeclarationSyntax;

        private static EnumInfo? TransformEnum(
            GeneratorAttributeSyntaxContext ctx,
            CancellationToken token
        )
        {
            // Check that symbol is a type

            var enumSymbol = ctx.TargetSymbol;

            if (enumSymbol is not ITypeSymbol enumType)
            {
                return null;
            }

            // Get attribute's properties

            var namedArgs = ctx.Attributes
                .Single()
                .NamedArguments
                .ToImmutableDictionary();

            // Get consts-defining class name

            if (
                !namedArgs.TryGetValue(
                    P_HasConstStrings_ConstClass,
                    out var clsNameConst
                )
                || clsNameConst.Value is not string clsName
            )
            {
                return null;
            }

            // Get enum name and namespace

            var enumName = enumSymbol.Name;

            var enumNamespace = enumSymbol.ContainingNamespace
                .ToDisplayString(
                    SymbolDisplayFormat.FullyQualifiedFormat
                )
                .Substring(PRE_Global.Length);

            // Get name and namespace of the generated class
            // and namespace for consts-defining class

            var clsNamespace = (
                namedArgs.TryGetValue(
                    P_HasConstStrings_ConstNamespace,
                    out var typedCt
                ) ? typedCt.Value as string : null
            ) ?? enumNamespace;

            var extName = (
                namedArgs.TryGetValue(
                    P_HasConstStrings_ExtClass,
                    out typedCt
                ) ? typedCt.Value as string : null
            ) ?? $"{enumName}{POST_Extensions}";

            var extNamespace = (
                namedArgs.TryGetValue(
                    P_HasConstStrings_ExtNamespace,
                    out typedCt
                ) ? typedCt.Value as string : null
            ) ?? enumNamespace;

            return new(
                enumName,
                enumNamespace,
                enumType
                    .GetMembers()
                    .Where(x => !x.IsImplicitlyDeclared)
                    .Select(x => x.Name)
                    .ToImmutableArray(),
                clsName,
                clsNamespace,
                extName,
                extNamespace
            );
        }

        private static void GenerateAttribute(
            IncrementalGeneratorPostInitializationContext ctx
        )
        {
            ctx.AddSource(
                $"{NS_Local}.{A_HasConstStringsFull}{EXT_GeneratedCSharp}",
                SourceText.From(AttributeSourceCode, Encoding.UTF8)
            );
        }

        private static void GenerateSourceCode(
            SourceProductionContext ctx,
            EnumInfo? enumInfo
        )
        {
            ctx.AddSource(
                $"{enumInfo!.EnumNamespace}.{enumInfo.EnumName}{EXT_GeneratedCSharp}",
                GenerateClass(enumInfo)
            );
        }

        private static string GenerateClass(EnumInfo enumInfo)
        {
            var items = enumInfo.EnumItems
                .Select(x => $"{PropTab}[{enumInfo.EnumName}.{x}] = {enumInfo.ClassName}.{x}");

            return $@"{C_Autogenerated}

{KW_Using} {PRE_Global}{NS_System_Collections_Generic};
{KW_Using} {PRE_Global}{enumInfo.ClassNamespace};
{KW_Using} {PRE_Global}{enumInfo.EnumNamespace};

{KW_Namespace} {enumInfo.ExtNamespace}
{{
    {KW_Public} {KW_Static} {KW_Partial} {KW_Class} {enumInfo.ExtName}
    {{
        {KW_Public} {KW_Static} {KW_String} {M_AsString}(
            {KW_This} {enumInfo.EnumName} value
        ) => _{enumInfo.EnumName}{POST_Dict}[value];

        {KW_Private} {KW_Static} {KW_Readonly} {nameof(Dictionary<int, int>)}<{enumInfo.EnumName}, {KW_String}> _{enumInfo.EnumName}{POST_Dict}
            = {KW_New}()
            {{
{string.Join($",{NewLine}", items)},
            }};
    }}
}}
";
        }
    }
}
