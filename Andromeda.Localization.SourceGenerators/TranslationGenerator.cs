using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using System;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Threading;
using Tommy;
using static Andromeda.CSharp.Consts.Comments;
using static Andromeda.CSharp.Consts.Extensions;
using static Andromeda.CSharp.Consts.Keywords;
using static Andromeda.Localization.SourceGenerators.InternalConsts;

namespace Andromeda.Localization.SourceGenerators
{
    [Generator(LanguageNames.CSharp)]
    public class TranslationGenerator : IIncrementalGenerator
    {
        public void Initialize(
            IncrementalGeneratorInitializationContext context
        )
        {
            var config = context.AdditionalTextsProvider
                .Where(IsLocalizationConfig)
                .Select(ParseLocalizationConfig);

            var tomls = context.AdditionalTextsProvider
                .Where(IsTomlFile)
                .Collect();

            var source = config
                .Combine(tomls)
                .Combine(context.AnalyzerConfigOptionsProvider)
                .Select(ParseInvariantFile);

            context.RegisterSourceOutput(source, (ctx, value) =>
            {
                ctx.AddSource(
                    $"{value.Namespace}.{value.Class}{EXT_GeneratedCSharp}",
                    GenerateSource(value)
                );
            });
        }

        private record LocalizationConfig(
            string Directory,
            string FullPath,
            TomlNode Class,
            TomlNode Namespace
        );

        private record InvariantConfig(
            TomlNode Class,
            TomlNode Namespace,
            TomlTable Translations,
            string? TranslationPath
        );

        private static bool IsLocalizationConfig(AdditionalText file)
            => Path.GetFileName(file.Path) == LocalizationConf;

        private static bool IsTomlFile(AdditionalText file)
            => file.Path.EndsWith(LocalizationConf_Ext);

        private static LocalizationConfig ParseLocalizationConfig(
            AdditionalText file,
            CancellationToken token
        )
        {
            var toml = TOML.Parse(
                new StringReader(file.GetText(token)?.ToString())
            );

            var dirName = Path.GetDirectoryName(file.Path);

            return new(
                dirName,
                Path.Combine(
                    dirName,
                    $"{toml[LocalizationConf_Invariant]}{LocalizationConf_Ext}"
                ),
                toml[LocalizationConf_Class],
                toml[LocalizationConf_Namespace]
            );
        }

        private static InvariantConfig ParseInvariantFile(
            (
                (
                    LocalizationConfig LConfig,
                    ImmutableArray<AdditionalText> TFiles
                ) LData,
                AnalyzerConfigOptionsProvider AOptions
            ) data,
            CancellationToken token
        )
        {
            data.AOptions.GlobalOptions
                .TryGetValue(AOptions_Project_Dir, out var projectDir);

            return new(
                data.LData.LConfig.Class,
                data.LData.LConfig.Namespace,
                TOML.Parse(
                    new StringReader(data.LData.TFiles
                        .FirstOrDefault(file => file.Path == data.LData.LConfig.FullPath)?
                        .GetText(token)?
                        .ToString()
                        ?? string.Empty
                    )
                ),
                data.LData.LConfig.Directory
                    .Substring((projectDir?.Length ?? 1) - 1)
            );
        }

        private static string GenerateSource(InvariantConfig config)
            => @$"{C_Autogenerated}

{KW_Using} {NS_Localization};
{KW_Using} {NS_Localization_Abstractions};

{KW_Namespace} {config.Namespace}
{{
    {KW_Public} {KW_Static} {KW_Class} {config.Class}
    {{
        {KW_Static} {config.Class}()
        {{
            {CL_TranslationProvider} = {KW_New} {CL_TranslationProvider}(
{Tab}{Tab}{Tab}{Tab}{KW_TypeOf}({config.Class}).{nameof(GetType)}().{nameof(Type.Assembly)},
{Tab}{Tab}{Tab}{Tab}""{config.TranslationPath}""
{Tab}{Tab}{Tab});

{string.Join("\n", config.Translations.AsTable.RawTable
    .Select(t => @$"{Tab}{Tab}{Tab}{t.Key} = {KW_New} {CL_TranslationUnit}(
{Tab}{Tab}{Tab}{Tab}{CL_TranslationProvider},
{Tab}{Tab}{Tab}{Tab}{KW_NameOf}({t.Key})
{Tab}{Tab}{Tab});")
)}
        }}

        {KW_Public} {KW_Static} {I_TranslationProvider} {CL_TranslationProvider} {{ {KW_Get}; }}

{string.Join("\n", config.Translations.AsTable.RawTable
    .Select(t => $"{Tab}{Tab}{KW_Public} {KW_Static} {I_TranslationUnit} {t.Key} {{ {KW_Get}; }}")
)}
    }}
}}
";
    }
}
